# -*- coding: utf-8 -*-
"""459_A3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/165h_enksWrIyJ_xqYlkR_ydiMVK9gf24
"""

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import math
#from google.colab import files

def LOF(k):

  df=pd.read_csv('outliers-3.csv')
  df['LOF'] = ""
  df['RD'] = ""
  #print(df["X1"])
  #print(df["X2"])

  #print(df.shape[0])
  for i in range(df.shape[0]):
    point_data = df.iloc[i,:]
    k_distance, k_neighbour = find_nearst_k(df,k,point_data)

    rd = average_RD(df,k_distance,k_neighbour,k)
    #neighbour_RD = 0
    """
    for j in range(len(k_neighbour)):
      index = k_neighbour[j]
      one_neighbour = df.iloc[index,:]
      k_distances, k_neighbours = find_nearst_k(df,k,one_neighbour)
      neighbour_RD+=average_RD(df,k_distances,k_neighbours,k)
    """

    df['RD'][i]=rd
  for j in range(df.shape[0]):
    neighbour_RD = 0
    point_data = df.iloc[j,:]
    k_distance, k_neighbour = find_nearst_k(df,k,point_data)
    for t in range(len(k_neighbour)):
      index = k_neighbour[t]

      neighbour_RD +=df['RD'][index]
    #print(neighbour_RD)
    #print(df['RD'][j])
    df['LOF'][j]=float(neighbour_RD/k/df['RD'][j])
  return df

"""
print(data)
point_data = df.iloc[132,:]
plt.scatter(df["X1"],df["X2"],color = "black",label = "inlier")

t,y = find_nearst_k(df,3,point_data)
print(t)
print(y)
test_df = df.loc[y, :]
plt.scatter(test_df["X1"],test_df["X2"],color = "red",label = "inlier")
"""

def find_nearst_k(data,k,point):
  dis_arr=[]
  neighbour_index=[]
  dis_arr = [math.inf for i in range(k)]
  neighbour_index = [math.inf for i in range(k)]
  x = float(point["X1"])
  y = float(point["X2"])
  #print(x,y)
  #print(data.shape[0])
  for i in range(data.shape[0]):
    points = data.iloc[i,:]

    point_x = float(points["X1"])
    point_y = float(points["X2"])
    #print(point_x,point_y)

    distance = math.sqrt((x-point_x)**2 + (y-point_y)**2 )
    for j in range(len(dis_arr)):
      if distance != 0:
        if distance<max(dis_arr):
          index = dis_arr.index(max(dis_arr))
          dis_arr[index] = distance
          neighbour_index[index] = i
          break
    #print(i)



  return dis_arr,neighbour_index

def average_RD(data,point_distance,neighbour_index,k):
  point_RD = 0

  for i in range(len(neighbour_index)):
    index = neighbour_index[i]

    one_neighbour = data.iloc[index,:]
    k_distance, k_neighbour = find_nearst_k(data,k,one_neighbour)

    #print(k_distance)
    #print(max(k_distance))

    if max(k_distance)>point_distance[i]:
      point_RD+=(max(k_distance))
    else:
      point_RD+=(point_distance[i])
  point_RD = point_RD/k
  return 1/point_RD

data = LOF(20)      #set K = 20

threshold = 1.1     # initialize threshold value
while True:

  df_inlier = data[data['LOF'] <= threshold]
  df_outlier = data[data['LOF'] >  threshold]
  if df_outlier.shape[0]/data.shape[0] < 0.05:    #assume 5% of data is outlier
    break
  else:
    threshold +=0.1

print(threshold)
plt.scatter(df_inlier["X1"],df_inlier["X2"],color = "black",label = "inlier")
plt.scatter(df_outlier["X1"],df_outlier["X2"],color = "red",label = "outlier")
plt.show()
"""df=pd.read_csv('outliers-3.csv')

point_data = df.iloc[132,:]
print(point_data)
k_distance, k_neighbour = find_nearst_k(df,3,point_data)
rd = average_RD(df,k_distance,k_neighbour,3)
neighbour_RD = 0
for i in range(len(k_neighbour)):
  index = k_neighbour[i]
  one_neighbour = df.iloc[index,:]
  k_distances, k_neighbours = find_nearst_k(df,3,one_neighbour)
  neighbour_RD+=average_RD(df,k_distances,k_neighbours,3)
print(rd,neighbour_RD)
print(neighbour_RD/3/rd)

df=pd.read_csv('outliers-3.csv')
point_data = df.iloc[0,:]
find_nearst_k(df,3,point_data)
"""
